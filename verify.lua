--[[
    ╔══════════════════════════════════════════════════════════╗
    ║              ZeroTrace — Key Verification               ║
    ║                                                         ║
    ║  This Lua module verifies keys generated by the         ║
    ║  ZeroTrace Key System website. It uses the EXACT same   ║
    ║  Date + Salt → SHA-256 hashing algorithm so no          ║
    ║  database or HTTP requests are needed.                  ║
    ║                                                         ║
    ║  USAGE:                                                 ║
    ║    local ZeroTrace = require(script.ZeroTrace)          ║
    ║    if ZeroTrace.verify(userKey) then                    ║
    ║        -- Key is valid, grant access                    ║
    ║    end                                                  ║
    ╚══════════════════════════════════════════════════════════╝
]]

local ZeroTrace = {}

-- ═══════════════════════════════════════════════════════════
-- CONFIG — Must match config.js on the website!
-- ═══════════════════════════════════════════════════════════
local SECRET_SALT = "ZeroTrace_S4lt_2025_xK9m"

-- ═══════════════════════════════════════════════════════════
-- SHA-256 IMPLEMENTATION (Pure Lua)
-- ═══════════════════════════════════════════════════════════

local band, bor, bxor, bnot, rshift, lshift
if bit32 then
    band = bit32.band
    bor = bit32.bor
    bxor = bit32.bxor
    bnot = bit32.bnot
    rshift = bit32.rshift
    lshift = bit32.lshift
else
    -- Fallback for environments without bit32 (uses bitwise ops in Lua 5.3+)
    band = function(a, b) return a & b end
    bor = function(a, b) return a | b end
    bxor = function(a, b) return a ~ b end
    bnot = function(a) return ~a end
    rshift = function(a, n) return a >> n end
    lshift = function(a, n) return a << n end
end

local function rrotate(x, n)
    x = band(x, 0xFFFFFFFF)
    return bor(rshift(x, n), lshift(x, 32 - n))
end

local K = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
}

local function sha256(message)
    -- Pre-processing
    local msg = { string.byte(message, 1, #message) }
    local len = #msg
    local bitlen = len * 8

    -- Append bit '1' (0x80)
    msg[#msg + 1] = 0x80

    -- Pad to 56 mod 64 bytes
    while (#msg % 64) ~= 56 do
        msg[#msg + 1] = 0x00
    end

    -- Append original length in bits as 64-bit big-endian
    for i = 7, 0, -1 do
        if i >= 4 then
            msg[#msg + 1] = 0 -- upper 32 bits (message < 2^32 bits)
        else
            msg[#msg + 1] = band(rshift(bitlen, i * 8), 0xFF)
        end
    end

    -- Initialize hash values
    local h0 = 0x6a09e667
    local h1 = 0xbb67ae85
    local h2 = 0x3c6ef372
    local h3 = 0xa54ff53a
    local h4 = 0x510e527f
    local h5 = 0x9b05688c
    local h6 = 0x1f83d9ab
    local h7 = 0x5be0cd19

    -- Process each 64-byte chunk
    for chunk = 1, #msg, 64 do
        local w = {}

        -- Break chunk into sixteen 32-bit big-endian words
        for i = 0, 15 do
            local idx = chunk + i * 4
            w[i] = bor(
                lshift(msg[idx], 24),
                lshift(msg[idx + 1], 16),
                lshift(msg[idx + 2], 8),
                msg[idx + 3]
            )
        end

        -- Extend the sixteen 32-bit words into sixty-four 32-bit words
        for i = 16, 63 do
            local s0 = bxor(rrotate(w[i-15], 7), rrotate(w[i-15], 18), rshift(w[i-15], 3))
            local s1 = bxor(rrotate(w[i-2], 17), rrotate(w[i-2], 19), rshift(w[i-2], 10))
            w[i] = band(w[i-16] + s0 + w[i-7] + s1, 0xFFFFFFFF)
        end

        -- Initialize working variables
        local a, b, c, d, e, f, g, h = h0, h1, h2, h3, h4, h5, h6, h7

        -- Compression function main loop
        for i = 0, 63 do
            local S1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))
            local ch = bxor(band(e, f), band(bnot(e), g))
            local temp1 = band(h + S1 + ch + K[i+1] + w[i], 0xFFFFFFFF)
            local S0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))
            local maj = bxor(band(a, b), band(a, c), band(b, c))
            local temp2 = band(S0 + maj, 0xFFFFFFFF)

            h = g
            g = f
            f = e
            e = band(d + temp1, 0xFFFFFFFF)
            d = c
            c = b
            b = a
            a = band(temp1 + temp2, 0xFFFFFFFF)
        end

        h0 = band(h0 + a, 0xFFFFFFFF)
        h1 = band(h1 + b, 0xFFFFFFFF)
        h2 = band(h2 + c, 0xFFFFFFFF)
        h3 = band(h3 + d, 0xFFFFFFFF)
        h4 = band(h4 + e, 0xFFFFFFFF)
        h5 = band(h5 + f, 0xFFFFFFFF)
        h6 = band(h6 + g, 0xFFFFFFFF)
        h7 = band(h7 + h, 0xFFFFFFFF)
    end

    return string.format(
        "%08x%08x%08x%08x%08x%08x%08x%08x",
        h0, h1, h2, h3, h4, h5, h6, h7
    )
end

-- ═══════════════════════════════════════════════════════════
-- GET UTC DATE STRING  (YYYY-MM-DD)
-- ═══════════════════════════════════════════════════════════
local function getUTCDateString()
    return os.date("!%Y-%m-%d")
end

-- ═══════════════════════════════════════════════════════════
-- GENERATE TODAY'S VALID KEY
-- ═══════════════════════════════════════════════════════════
function ZeroTrace.generateTodayKey()
    local dateStr = getUTCDateString()
    local raw = dateStr .. SECRET_SALT
    local hash = sha256(raw)
    local hex9 = string.upper(string.sub(hash, 1, 9))
    local p1 = string.sub(hex9, 1, 3)
    local p2 = string.sub(hex9, 4, 6)
    local p3 = string.sub(hex9, 7, 9)
    return "[key" .. p1 .. "-" .. p2 .. "-" .. p3 .. "]"
end

-- ═══════════════════════════════════════════════════════════
-- VERIFY A USER-PROVIDED KEY
-- Returns: boolean, string (isValid, message)
-- ═══════════════════════════════════════════════════════════
function ZeroTrace.verify(userKey)
    if type(userKey) ~= "string" then
        return false, "Invalid key format: expected string"
    end

    -- Trim whitespace
    userKey = userKey:match("^%s*(.-)%s*$")

    -- Validate format: [keyXXX-XXX-XXX]
    if not userKey:match("^%[key%w%w%w%-%w%w%w%-%w%w%w%]$") then
        return false, "Invalid key format: expected [keyXXX-XXX-XXX]"
    end

    local todayKey = ZeroTrace.generateTodayKey()

    if userKey:upper() == todayKey:upper() then
        return true, "Key verified successfully! Access granted."
    else
        return false, "Key expired or invalid. Please generate a new key."
    end
end

-- ═══════════════════════════════════════════════════════════
-- EXAMPLE USAGE (uncomment to test)
-- ═══════════════════════════════════════════════════════════
--[[
    print("Today's valid key: " .. ZeroTrace.generateTodayKey())

    -- Test verification
    local testKey = "[keyABC-DEF-123]"
    local valid, msg = ZeroTrace.verify(testKey)
    print(valid, msg)

    -- Verify today's key
    local todayKey = ZeroTrace.generateTodayKey()
    local valid2, msg2 = ZeroTrace.verify(todayKey)
    print(valid2, msg2) -- true, "Key verified successfully! Access granted."
]]

return ZeroTrace
